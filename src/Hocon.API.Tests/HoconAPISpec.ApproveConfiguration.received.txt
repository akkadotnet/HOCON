[assembly: System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.6.1", FrameworkDisplayName=".NET Framework 4.6.1")]
namespace Hocon
{
    public abstract class CDataConfigurationElement : System.Configuration.ConfigurationElement
    {
        protected const string ContentPropertyName = "content";
        protected CDataConfigurationElement() { }
        protected override void DeserializeElement(System.Xml.XmlReader reader, bool serializeCollectionKey) { }
    }
    public class Config
    {
        public static readonly Hocon.Config Empty;
        public Config() { }
        public Config(Hocon.HoconRoot root) { }
        public Config(Hocon.Config source) { }
        public Config(Hocon.Config source, Hocon.Config fallback) { }
        public Hocon.Config Fallback { get; }
        public virtual bool IsEmpty { get; }
        public Hocon.HoconValue Root { get; }
        public System.Collections.Generic.IEnumerable<Hocon.HoconSubstitution> Substitutions { get; set; }
        public Hocon.HoconValue Value { get; }
        public virtual System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Hocon.HoconValue>> AsEnumerable() { }
        protected Hocon.Config Copy(Hocon.Config fallback = null) { }
        public virtual bool GetBoolean(string path, bool default = False) { }
        public virtual System.Collections.Generic.IList<bool> GetBooleanList(string path) { }
        public virtual System.Collections.Generic.IList<byte> GetByteList(string path) { }
        public virtual System.Nullable<long> GetByteSize(string path) { }
        public virtual Hocon.Config GetConfig(string path) { }
        public virtual decimal GetDecimal(string path, [System.Runtime.CompilerServices.DecimalConstantAttribute(0, 0, 0u, 0u, 0u)] decimal @default) { }
        public virtual System.Collections.Generic.IList<decimal> GetDecimalList(string path) { }
        public virtual double GetDouble(string path, double default = 0) { }
        public virtual System.Collections.Generic.IList<double> GetDoubleList(string path) { }
        public virtual float GetFloat(string path, float default = 0) { }
        public virtual System.Collections.Generic.IList<float> GetFloatList(string path) { }
        public virtual int GetInt(string path, int default = 0) { }
        public virtual System.Collections.Generic.IList<int> GetIntList(string path) { }
        public virtual long GetLong(string path, long default = 0) { }
        public virtual System.Collections.Generic.IList<long> GetLongList(string path) { }
        public virtual string GetString(string path, string default = null) { }
        public virtual string GetString(Hocon.HoconPath path, string default = null) { }
        public virtual System.Collections.Generic.IList<string> GetStringList(string path) { }
        public virtual System.Collections.Generic.IList<string> GetStringList(Hocon.HoconPath path) { }
        public virtual System.TimeSpan GetTimeSpan(string path, System.Nullable<System.TimeSpan> default = null, bool allowInfinite = True) { }
        public Hocon.HoconValue GetValue(string path) { }
        public virtual bool HasPath(string path) { }
        public string PrettyPrint(int indentSize) { }
        public override string ToString() { }
        public string ToString(bool includeFallback) { }
        public virtual Hocon.Config WithFallback(Hocon.Config fallback) { }
        public static Hocon.Config +(Hocon.Config config, string fallback) { }
        public static Hocon.Config +(string configHocon, Hocon.Config fallbackConfig) { }
        public static Hocon.Config op_Implicit(string str) { }
    }
    public class static ConfigExtensions
    {
        public static bool IsNullOrEmpty(this Hocon.Config config) { }
        public static Hocon.Config SafeWithFallback(this Hocon.Config config, Hocon.Config fallback) { }
    }
    public class ConfigurationException : System.Exception
    {
        public ConfigurationException(string message) { }
        public ConfigurationException(string message, System.Exception exception) { }
        protected ConfigurationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
        public static Hocon.ConfigurationException NullOrEmptyConfig<T>(string path = null) { }
    }
    public class static DebuggingExtensions
    {
        public static string DumpConfig(this Hocon.Config c, bool dumpAsFallbacks = True) { }
    }
    public class HoconConfigurationElement : Hocon.CDataConfigurationElement
    {
        public HoconConfigurationElement() { }
        [System.Configuration.ConfigurationPropertyAttribute("content", IsKey=true, IsRequired=true)]
        public string Content { get; set; }
    }
    public class static HoconConfigurationFactory
    {
        public static Hocon.Config Empty { get; }
        public static Hocon.Config Default() { }
        public static Hocon.Config FromFile(string filePath) { }
        public static Hocon.Config FromResource(string resourceName, object instanceInAssembly) { }
        public static Hocon.Config FromResource<TAssembly>(string resourceName) { }
        public static Hocon.Config FromResource(string resourceName, System.Reflection.Assembly assembly) { }
        [System.ObsoleteAttribute("Call the ConfigurationFactory.Default method instead.")]
        public static Hocon.Config Load() { }
        public static Hocon.Config Load(string sectionName) { }
        public static Hocon.Config ParseString(string hocon, Hocon.HoconIncludeCallbackAsync includeCallback) { }
        public static Hocon.Config ParseString(string hocon) { }
    }
    public class HoconConfigurationSection : System.Configuration.ConfigurationSection
    {
        public HoconConfigurationSection() { }
        public Hocon.Config Config { get; }
        [System.Configuration.ConfigurationPropertyAttribute("hocon", IsRequired=true)]
        public Hocon.HoconConfigurationElement Hocon { get; set; }
    }
}